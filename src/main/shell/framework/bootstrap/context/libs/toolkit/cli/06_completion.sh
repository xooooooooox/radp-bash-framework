#!/usr/bin/env bash
# toolkit module: cli/06_completion.sh
# 补全脚本生成：生成 bash/zsh 自动补全脚本

#######################################
# 生成 Bash 补全脚本
# Outputs:
#   完整的 Bash 补全脚本
#######################################
radp_cli_completion_bash() {
    local app_name="${__radp_cli_app_name:-cli}"
    local app_func="${app_name//-/_}"

    cat << BASH_COMPLETION_HEADER
# Bash completion script for $app_name
# Generated by radp-bash-framework

BASH_COMPLETION_HEADER

    # 替换应用名
    cat << BASH_COMPLETION_FUNC
_${app_func}() {
    local cur prev words cword

    # 兼容模式：如果 _init_completion 不存在，使用手动初始化
    if type _init_completion &>/dev/null; then
        _init_completion || return
    else
        COMPREPLY=()
        cur="\${COMP_WORDS[COMP_CWORD]}"
        prev="\${COMP_WORDS[COMP_CWORD-1]}"
        words=("\${COMP_WORDS[@]}")
        cword="\$COMP_CWORD"
    fi

    local i cmd_path=""

    # 构建当前命令路径
    for ((i = 1; i < cword; i++)); do
        case "\${words[i]}" in
            -*) continue ;;
            *)
                if [[ -z "\$cmd_path" ]]; then
                    cmd_path="\${words[i]}"
                else
                    cmd_path="\$cmd_path \${words[i]}"
                fi
                ;;
        esac
    done

BASH_COMPLETION_FUNC

    # 生成命令补全逻辑
    echo "    # Command completions"
    echo "    case \"\$cmd_path\" in"

    # 顶级补全
    local top_commands
    top_commands=$(radp_cli_list_commands | tr '\n' ' ')
    echo "        '')"
    echo "            COMPREPLY=(\$(compgen -W \"$top_commands --help --version\" -- \"\$cur\"))"
    echo "            ;;"

    # 为每个有子命令的命令组生成补全
    local cmd
    for cmd in $(radp_cli_list_commands); do
        if radp_cli_has_subcommands "$cmd"; then
            local subcommands
            subcommands=$(radp_cli_list_subcommands "$cmd" | tr '\n' ' ')
            echo "        '$cmd')"
            echo "            COMPREPLY=(\$(compgen -W \"$subcommands --help\" -- \"\$cur\"))"
            echo "            ;;"
        fi

        # 为具体命令生成选项补全
        if radp_cli_cmd_exists "$cmd"; then
            local -A meta=()
            if radp_cli_get_cmd_meta "$cmd" meta 2>/dev/null; then
                local options="--help"
                local opt_line
                while IFS= read -r opt_line; do
                    [[ -z "$opt_line" ]] && continue
                    local -A opt_info=()
                    radp_cli_parse_option_spec "$opt_line" opt_info
                    [[ -n "${opt_info[short]}" ]] && options+=" -${opt_info[short]}"
                    [[ -n "${opt_info[long]}" ]] && options+=" --${opt_info[long]}"
                done <<< "${meta[options]}"

                # 只有当命令没有子命令时才输出
                if ! radp_cli_has_subcommands "$cmd"; then
                    echo "        '$cmd')"
                    echo "            COMPREPLY=(\$(compgen -W \"$options\" -- \"\$cur\"))"
                    echo "            ;;"
                fi
            fi
        fi

        # 处理二级命令
        local subcmd
        for subcmd in $(radp_cli_list_subcommands "$cmd"); do
            local full_cmd="$cmd $subcmd"
            if radp_cli_cmd_exists "$full_cmd"; then
                local -A sub_meta=()
                if radp_cli_get_cmd_meta "$full_cmd" sub_meta 2>/dev/null; then
                    local options="--help"
                    local opt_line
                    while IFS= read -r opt_line; do
                        [[ -z "$opt_line" ]] && continue
                        local -A opt_info=()
                        radp_cli_parse_option_spec "$opt_line" opt_info
                        [[ -n "${opt_info[short]}" ]] && options+=" -${opt_info[short]}"
                        [[ -n "${opt_info[long]}" ]] && options+=" --${opt_info[long]}"
                    done <<< "${sub_meta[options]}"

                    echo "        '$full_cmd')"
                    echo "            COMPREPLY=(\$(compgen -W \"$options\" -- \"\$cur\"))"
                    echo "            ;;"
                fi
            fi
        done
    done

    echo "        *)"
    echo "            COMPREPLY=()"
    echo "            ;;"
    echo "    esac"
    echo "}"
    echo
    echo "complete -F _${app_name//-/_} $app_name"
}

#######################################
# 生成 Zsh 补全脚本
# Outputs:
#   完整的 Zsh 补全脚本
#######################################
radp_cli_completion_zsh() {
    local app_name="${__radp_cli_app_name:-cli}"

    cat << ZSH_COMPLETION_HEADER
#compdef $app_name

# Zsh completion script for $app_name
# Generated by radp-bash-framework

ZSH_COMPLETION_HEADER

    cat << 'ZSH_COMPLETION_FUNC'
_APP_NAME() {
    local context state state_descr line
    typeset -A opt_args

    _arguments -C \
        '1: :->command' \
        '*:: :->args'

    case "$state" in
        command)
            local commands=(
ZSH_COMPLETION_FUNC

    # 生成顶级命令列表
    local cmd
    for cmd in $(radp_cli_list_commands); do
        local desc=""
        local -A meta=()
        if radp_cli_cmd_exists "$cmd"; then
            radp_cli_get_cmd_meta "$cmd" meta 2>/dev/null || true
            desc="${meta[desc]:-}"
        elif radp_cli_has_subcommands "$cmd"; then
            desc="Manage $cmd"
        fi
        # 转义单引号
        desc="${desc//\'/\'\\\'\'}"
        echo "                '$cmd:$desc'"
    done

    cat << 'ZSH_COMPLETION_MIDDLE'
            )
            _describe 'command' commands
            ;;
        args)
            case "${words[1]}" in
ZSH_COMPLETION_MIDDLE

    # 为每个命令生成子命令或选项补全
    for cmd in $(radp_cli_list_commands); do
        echo "                $cmd)"

        if radp_cli_has_subcommands "$cmd"; then
            # 有子命令
            echo "                    local subcommands=("
            local subcmd
            for subcmd in $(radp_cli_list_subcommands "$cmd"); do
                local desc=""
                local -A sub_meta=()
                if radp_cli_get_cmd_meta "$cmd $subcmd" sub_meta 2>/dev/null; then
                    desc="${sub_meta[desc]:-}"
                fi
                desc="${desc//\'/\'\\\'\'}"
                echo "                        '$subcmd:$desc'"
            done
            echo "                    )"
            echo "                    _describe 'subcommand' subcommands"
        else
            # 没有子命令，补全选项
            echo "                    _arguments \\"
            echo "                        '(-h --help)'{-h,--help}'[Show help]' \\"

            if radp_cli_cmd_exists "$cmd"; then
                local -A meta=()
                if radp_cli_get_cmd_meta "$cmd" meta 2>/dev/null; then
                    local opt_line
                    while IFS= read -r opt_line; do
                        [[ -z "$opt_line" ]] && continue
                        local -A opt_info=()
                        radp_cli_parse_option_spec "$opt_line" opt_info

                        local opt_spec=""
                        if [[ -n "${opt_info[short]}" && -n "${opt_info[long]}" ]]; then
                            opt_spec="(-${opt_info[short]} --${opt_info[long]})'{-${opt_info[short]},--${opt_info[long]}}"
                        elif [[ -n "${opt_info[long]}" ]]; then
                            opt_spec="'--${opt_info[long]}"
                        fi

                        if [[ -n "$opt_spec" ]]; then
                            local desc="${opt_info[desc]//\'/\'\\\'\'}"
                            if [[ "${opt_info[has_value]}" == "true" ]]; then
                                echo "                        ${opt_spec}[${desc}]:${opt_info[value_name]}:' \\"
                            else
                                echo "                        ${opt_spec}[${desc}]' \\"
                            fi
                        fi
                    done <<< "${meta[options]}"
                fi
            fi
            echo "                        '*:file:_files'"
        fi

        echo "                    ;;"
    done

    cat << 'ZSH_COMPLETION_FOOTER'
                *)
                    _files
                    ;;
            esac
            ;;
    esac
}

_APP_NAME "$@"
ZSH_COMPLETION_FOOTER

    # 替换占位符
    sed -i.bak "s/APP_NAME/${app_name//-/_}/g" 2>/dev/null || true
}

#######################################
# 生成补全脚本（统一入口）
# Arguments:
#   1 - shell: shell 类型（bash 或 zsh）
# Outputs:
#   补全脚本
# Returns:
#   0 - 成功
#   1 - 不支持的 shell 类型
#######################################
radp_cli_completion_generate() {
    local shell="$1"

    case "$shell" in
        bash)
            radp_cli_completion_bash
            ;;
        zsh)
            radp_cli_completion_zsh
            ;;
        *)
            radp_log_error "Unsupported shell: $shell (supported: bash, zsh)"
            return 1
            ;;
    esac
}
