#!/usr/bin/env bash
# toolkit module: cli/06_completion.sh
# 补全脚本生成：生成 bash/zsh 自动补全脚本

#######################################
# 生成 Bash 补全脚本
# Outputs:
#   完整的 Bash 补全脚本
#######################################
radp_cli_completion_bash() {
  local app_name="${__radp_cli_app_name:-cli}"
  local app_func="${app_name//-/_}"

  cat <<BASH_COMPLETION_HEADER
# Bash completion script for $app_name
# Generated by radp-bash-framework

BASH_COMPLETION_HEADER

  # 替换应用名
  cat <<BASH_COMPLETION_FUNC
_${app_func}() {
    local cur prev words cword

    # 兼容模式：如果 _init_completion 不存在，使用手动初始化
    if type _init_completion &>/dev/null; then
        _init_completion || return
    else
        COMPREPLY=()
        cur="\${COMP_WORDS[COMP_CWORD]}"
        prev="\${COMP_WORDS[COMP_CWORD-1]}"
        words=("\${COMP_WORDS[@]}")
        cword="\$COMP_CWORD"
    fi

    local i cmd_path=""

    # 构建当前命令路径
    for ((i = 1; i < cword; i++)); do
        case "\${words[i]}" in
            -*) continue ;;
            *)
                if [[ -z "\$cmd_path" ]]; then
                    cmd_path="\${words[i]}"
                else
                    cmd_path="\$cmd_path \${words[i]}"
                fi
                ;;
        esac
    done

BASH_COMPLETION_FUNC

  # 生成命令补全逻辑
  echo "    # Command completions"
  echo "    case \"\$cmd_path\" in"

  # 顶级补全
  local top_commands
  top_commands=$(radp_cli_list_commands | tr '\n' ' ')
  echo "        '')"
  echo "            COMPREPLY=(\$(compgen -W \"$top_commands --help --version\" -- \"\$cur\"))"
  echo "            ;;"

  # 递归生成所有命令路径的补全
  __radp_cli_bash_gen_all_completions ""

  echo "        *)"
  echo "            COMPREPLY=()"
  echo "            ;;"
  echo "    esac"
  echo "}"
  echo
  echo "complete -F _${app_name//-/_} $app_name"
}

#######################################
# 递归生成 Bash 命令补全（内部函数）
# Arguments:
#   1 - parent_path: 父命令路径（空字符串表示顶级）
#######################################
__radp_cli_bash_gen_all_completions() {
  local parent_path="$1"
  local cmd_list

  if [[ -z "$parent_path" ]]; then
    cmd_list=$(radp_cli_list_commands)
  else
    cmd_list=$(radp_cli_list_subcommands "$parent_path")
  fi

  local cmd
  for cmd in $cmd_list; do
    local full_path
    if [[ -z "$parent_path" ]]; then
      full_path="$cmd"
    else
      full_path="$parent_path $cmd"
    fi

    if radp_cli_has_subcommands "$full_path"; then
      # 有子命令：补全子命令列表
      local subcommands
      subcommands=$(radp_cli_list_subcommands "$full_path" | tr '\n' ' ')
      echo "        '$full_path')"
      echo "            COMPREPLY=(\$(compgen -W \"$subcommands --help\" -- \"\$cur\"))"
      echo "            ;;"

      # 递归处理子命令
      __radp_cli_bash_gen_all_completions "$full_path"
    elif radp_cli_cmd_exists "$full_path"; then
      # 没有子命令：生成补全逻辑
      __radp_cli_bash_gen_cmd_completion "$full_path"
    fi
  done
}

#######################################
# 生成单个命令的 Bash 补全逻辑（内部函数）
# 支持静态选项补全和动态参数/选项值补全
# Arguments:
#   1 - cmd_path: 命令路径
#######################################
__radp_cli_bash_gen_cmd_completion() {
  local cmd_path="$1"

  local -A meta=()
  if ! radp_cli_get_cmd_meta "$cmd_path" meta 2>/dev/null; then
    return
  fi

  # 检查是否是透传模式 - 只生成 --help 补全
  local is_passthrough=false
  if [[ "${meta[metas]}" == *passthrough* ]]; then
    is_passthrough=true
  fi

  local options="--help"
  local -a opt_with_value=()
  local -A opt_complete_funcs=()

  # 非透传模式才解析选项
  if [[ "$is_passthrough" != "true" ]]; then
    local opt_line
    while IFS= read -r opt_line; do
      [[ -z "$opt_line" ]] && continue
      local -A opt_info=()
      radp_cli_parse_option_spec "$opt_line" opt_info
      [[ -n "${opt_info[short]}" ]] && options+=" -${opt_info[short]}"
      [[ -n "${opt_info[long]}" ]] && options+=" --${opt_info[long]}"

      # 记录需要值的选项
      if [[ "${opt_info[has_value]}" == "true" && -n "${opt_info[long]}" ]]; then
        opt_with_value+=("${opt_info[long]}")
        [[ -n "${opt_info[short]}" ]] && opt_with_value+=("${opt_info[short]}")

        # 检查是否有动态补全函数
        local complete_func
        if complete_func=$(radp_cli_get_complete_func "${opt_info[long]}" "${meta[completes]}" 2>/dev/null); then
          opt_complete_funcs["${opt_info[long]}"]="$complete_func"
          [[ -n "${opt_info[short]}" ]] && opt_complete_funcs["${opt_info[short]}"]="$complete_func"
        fi
      fi
    done <<<"${meta[options]}"
  fi

  # 解析参数的动态补全（非透传模式）
  local -a arg_complete_funcs=()
  if [[ "$is_passthrough" != "true" ]]; then
    local arg_line arg_idx=0
    while IFS= read -r arg_line; do
      [[ -z "$arg_line" ]] && continue
      local -A arg_info=()
      radp_cli_parse_arg_spec "$arg_line" arg_info
      local complete_func
      if complete_func=$(radp_cli_get_complete_func "${arg_info[name]}" "${meta[completes]}" 2>/dev/null); then
        arg_complete_funcs[$arg_idx]="$complete_func"
      fi
      ((arg_idx++)) || true
    done <<<"${meta[args]}"
  fi

  # 计算命令路径深度（用于 arg_idx 偏移）
  local cmd_depth
  cmd_depth=$(echo "$cmd_path" | wc -w | tr -d ' ')

  # 生成补全代码
  echo "        '$cmd_path')"

  # 检查是否需要复杂的补全逻辑
  if [[ ${#opt_complete_funcs[@]} -gt 0 || ${#arg_complete_funcs[@]} -gt 0 ]]; then
    # 有动态补全：生成复杂逻辑

    # 只有当有选项动态补全时才生成 case "$prev"
    if [[ ${#opt_complete_funcs[@]} -gt 0 ]]; then
      echo "            case \"\$prev\" in"
      # 为每个有动态补全的选项生成 case
      for opt in "${!opt_complete_funcs[@]}"; do
        local func="${opt_complete_funcs[$opt]}"
        if [[ ${#opt} -eq 1 ]]; then
          echo "                -$opt)"
        else
          echo "                --$opt)"
        fi
        echo "                    local completions"
        echo "                    completions=\$($func 2>/dev/null)"
        echo "                    COMPREPLY=(\$(compgen -W \"\$completions\" -- \"\$cur\"))"
        echo "                    return"
        echo "                    ;;"
      done
      echo "            esac"
    fi

    # 参数位置的动态补全
    if [[ ${#arg_complete_funcs[@]} -gt 0 ]]; then
      echo "            # 计算参数位置（减去命令路径深度）"
      echo "            local arg_idx=0"
      echo "            for ((i = 1; i < cword; i++)); do"
      echo "                case \"\${words[i]}\" in"
      echo "                    -*) ;;"
      echo "                    *) ((arg_idx++)) ;;"
      echo "                esac"
      echo "            done"
      echo "            ((arg_idx -= $cmd_depth)) || true"
      echo "            # 根据参数位置补全"
      echo "            case \"\$arg_idx\" in"
      for idx in "${!arg_complete_funcs[@]}"; do
        local func="${arg_complete_funcs[$idx]}"
        echo "                $idx)"
        echo "                    local completions"
        echo "                    completions=\$($func 2>/dev/null)"
        echo "                    COMPREPLY=(\$(compgen -W \"\$completions\" -- \"\$cur\"))"
        echo "                    return"
        echo "                    ;;"
      done
      echo "            esac"
    fi

    echo "            COMPREPLY=(\$(compgen -W \"$options\" -- \"\$cur\"))"
  else
    # 无动态补全：简单的选项补全
    echo "            COMPREPLY=(\$(compgen -W \"$options\" -- \"\$cur\"))"
  fi

  echo "            ;;"
}

#######################################
# 生成 Zsh 动态补全的 wrapper 函数
# 遍历所有命令，为每个动态补全生成一个 wrapper 函数
# Arguments:
#   1 - app_func: 应用函数名前缀
#######################################
__radp_cli_zsh_gen_completion_wrappers() {
  local app_func="$1"

  # 递归遍历所有命令
  __radp_cli_zsh_gen_wrappers_for_path "" "$app_func"
}

#######################################
# 递归生成指定路径下的 wrapper 函数
#######################################
__radp_cli_zsh_gen_wrappers_for_path() {
  local parent_path="$1"
  local app_func="$2"
  local cmd_list

  if [[ -z "$parent_path" ]]; then
    cmd_list=$(radp_cli_list_commands)
  else
    cmd_list=$(radp_cli_list_subcommands "$parent_path")
  fi

  local cmd
  for cmd in $cmd_list; do
    local full_path
    if [[ -z "$parent_path" ]]; then
      full_path="$cmd"
    else
      full_path="$parent_path $cmd"
    fi

    if radp_cli_has_subcommands "$full_path"; then
      # 递归处理子命令
      __radp_cli_zsh_gen_wrappers_for_path "$full_path" "$app_func"
    elif radp_cli_cmd_exists "$full_path"; then
      # 为该命令生成 wrapper 函数
      __radp_cli_zsh_gen_cmd_wrappers "$full_path" "$app_func"
    fi
  done
}

#######################################
# 为单个命令生成动态补全的 wrapper 函数
#######################################
__radp_cli_zsh_gen_cmd_wrappers() {
  local cmd_path="$1"
  local app_func="$2"

  local -A meta=()
  if ! radp_cli_get_cmd_meta "$cmd_path" meta 2>/dev/null; then
    return
  fi

  # 跳过透传模式
  if [[ "${meta[metas]}" == *passthrough* ]]; then
    return
  fi

  # 将命令路径转换为函数名后缀 (setup info -> setup_info)
  local func_suffix="${cmd_path// /_}"

  # 为参数生成 wrapper
  local arg_line arg_idx=1
  while IFS= read -r arg_line; do
    [[ -z "$arg_line" ]] && continue
    local -A arg_info=()
    radp_cli_parse_arg_spec "$arg_line" arg_info

    local complete_func
    if complete_func=$(radp_cli_get_complete_func "${arg_info[name]}" "${meta[completes]}" 2>/dev/null); then
      local wrapper_name="_${app_func}_arg_${func_suffix}_${arg_info[name]}"
      cat <<WRAPPER
${wrapper_name}() {
    local completions=(\$($complete_func 2>/dev/null))
    _describe '${arg_info[name]}' completions
}

WRAPPER
    fi
    ((arg_idx++)) || true
  done <<<"${meta[args]}"

  # 为选项值生成 wrapper
  local opt_line
  while IFS= read -r opt_line; do
    [[ -z "$opt_line" ]] && continue
    local -A opt_info=()
    radp_cli_parse_option_spec "$opt_line" opt_info

    if [[ "${opt_info[has_value]}" == "true" && -n "${opt_info[long]}" ]]; then
      local complete_func
      if complete_func=$(radp_cli_get_complete_func "${opt_info[long]}" "${meta[completes]}" 2>/dev/null); then
        local opt_name="${opt_info[long]//-/_}"
        local wrapper_name="_${app_func}_opt_${func_suffix}_${opt_name}"
        cat <<WRAPPER
${wrapper_name}() {
    local completions=(\$($complete_func 2>/dev/null))
    _describe '${opt_info[value_name]}' completions
}

WRAPPER
      fi
    fi
  done <<<"${meta[options]}"
}

#######################################
# 生成 Zsh 补全脚本
# Outputs:
#   完整的 Zsh 补全脚本
#######################################
radp_cli_completion_zsh() {
  local app_name="${__radp_cli_app_name:-cli}"
  local app_func="${app_name//-/_}"

  # 输出 #compdef 头部
  echo "#compdef $app_name"
  echo ""
  echo "# Zsh completion script for $app_name"
  echo "# Generated by radp-bash-framework"
  echo ""

  # 生成所有动态补全的 wrapper 函数
  __radp_cli_zsh_gen_completion_wrappers "$app_func"

  cat <<ZSH_COMPLETION_HEADER
_${app_func}() {
    local context state state_descr line
    typeset -A opt_args

    _arguments -C \\
        '1: :->command' \\
        '*:: :->args'

    case "\$state" in
        command)
            local commands=(
ZSH_COMPLETION_HEADER

  # 生成顶级命令列表
  local cmd
  for cmd in $(radp_cli_list_commands); do
    local desc=""
    local -A meta=()
    if radp_cli_cmd_exists "$cmd"; then
      radp_cli_get_cmd_meta "$cmd" meta 2>/dev/null || true
      desc="${meta[desc]:-}"
    elif radp_cli_has_subcommands "$cmd"; then
      desc="Manage $cmd"
    fi
    # 转义单引号
    desc="${desc//\'/\'\\\'\'}"
    echo "                '$cmd:$desc'"
  done

  cat <<'ZSH_COMPLETION_MIDDLE'
            )
            _describe 'command' commands
            ;;
        args)
            case "${words[1]}" in
ZSH_COMPLETION_MIDDLE

  # 为每个命令生成子命令或选项补全
  for cmd in $(radp_cli_list_commands); do
    __radp_cli_zsh_gen_cmd_completion "$cmd" "words[1]" 16
  done

  cat <<'ZSH_COMPLETION_FOOTER'
                *)
                    _files
                    ;;
            esac
            ;;
    esac
}
ZSH_COMPLETION_FOOTER

  echo
  echo "_${app_func} \"\$@\""
}

#######################################
# 递归生成 Zsh 命令补全（内部函数）
# Arguments:
#   1 - cmd_path: 当前命令路径
#   2 - words_expr: words 表达式（用于嵌套 case）
#   3 - indent: 缩进空格数
#######################################
__radp_cli_zsh_gen_cmd_completion() {
  local cmd_path="$1"
  local words_expr="$2"
  local indent="$3"
  local pad=""
  local i
  for ((i = 0; i < indent; i++)); do pad+=" "; done

  local cmd_name="${cmd_path##* }"
  echo "${pad}${cmd_name})"

  if radp_cli_has_subcommands "$cmd_path"; then
    # 有子命令：生成子命令列表
    echo "${pad}    local subcommands=("
    local subcmd
    for subcmd in $(radp_cli_list_subcommands "$cmd_path"); do
      local desc=""
      local -A sub_meta=()
      local full_path="$cmd_path $subcmd"
      if radp_cli_cmd_exists "$full_path"; then
        radp_cli_get_cmd_meta "$full_path" sub_meta 2>/dev/null || true
        desc="${sub_meta[desc]:-}"
      elif radp_cli_has_subcommands "$full_path"; then
        desc="Manage $subcmd"
      fi
      desc="${desc//\'/\'\\\'\'}"
      echo "${pad}        '$subcmd:$desc'"
    done
    echo "${pad}    )"

    # 计算当前深度
    local depth
    depth=$(echo "$cmd_path" | wc -w | tr -d ' ')
    local next_word_idx=$((depth + 1))

    echo "${pad}    case \"\${words[$next_word_idx]}\" in"

    # 递归处理子命令
    for subcmd in $(radp_cli_list_subcommands "$cmd_path"); do
      __radp_cli_zsh_gen_cmd_completion "$cmd_path $subcmd" "words[$next_word_idx]" $((indent + 4))
    done

    echo "${pad}        *)"
    echo "${pad}            _describe 'subcommand' subcommands"
    echo "${pad}            ;;"
    echo "${pad}    esac"
  else
    # 没有子命令：补全选项和参数
    __radp_cli_zsh_gen_args_completion "$cmd_path" "$pad"
  fi

  echo "${pad}    ;;"
}

#######################################
# 生成 Zsh 参数和选项补全（内部函数）
# 使用 wrapper 函数替代 state actions，避免嵌套上下文问题
# Arguments:
#   1 - cmd_path: 命令路径
#   2 - pad: 缩进字符串
#######################################
__radp_cli_zsh_gen_args_completion() {
  local cmd_path="$1"
  local pad="$2"
  local app_func="${__radp_cli_app_name//-/_}"

  # 将命令路径转换为函数名后缀 (setup info -> setup_info)
  local func_suffix="${cmd_path// /_}"

  # 计算命令深度，用于移位 words 和 CURRENT
  # 例如 "setup info" 深度为 2，需要移除 words 中的 "setup" 和 "info"
  local depth
  depth=$(echo "$cmd_path" | wc -w | tr -d ' ')

  # 移位 words 和 CURRENT，使 _arguments 从正确位置开始解析
  echo "${pad}    # Shift words array for nested subcommand (depth=$depth)"
  echo "${pad}    words=(\"\${words[@]:$depth}\")"
  echo "${pad}    (( CURRENT -= $depth ))"
  echo ""
  echo "${pad}    _arguments \\"
  echo "${pad}        '(-h --help)'{-h,--help}'[Show help]' \\"

  if ! radp_cli_cmd_exists "$cmd_path"; then
    echo "${pad}        '*:file:_files'"
    return
  fi

  local -A meta=()
  if ! radp_cli_get_cmd_meta "$cmd_path" meta 2>/dev/null; then
    echo "${pad}        '*:file:_files'"
    return
  fi

  # 检查是否是透传模式 - 只保留 --help，其余作为 passthrough
  if [[ "${meta[metas]}" == *passthrough* ]]; then
    echo "${pad}        '*:args:'"
    return
  fi

  # 生成选项补全
  local opt_line
  while IFS= read -r opt_line; do
    [[ -z "$opt_line" ]] && continue
    local -A opt_info=()
    radp_cli_parse_option_spec "$opt_line" opt_info

    local opt_spec=""
    if [[ -n "${opt_info[short]}" && -n "${opt_info[long]}" ]]; then
      opt_spec="(-${opt_info[short]} --${opt_info[long]})'{-${opt_info[short]},--${opt_info[long]}}"
    elif [[ -n "${opt_info[long]}" ]]; then
      opt_spec="'--${opt_info[long]}"
    fi

    if [[ -n "$opt_spec" ]]; then
      local desc="${opt_info[desc]//\'/\'\\\'\'}"
      if [[ "${opt_info[has_value]}" == "true" ]]; then
        # 检查是否有动态补全函数
        local complete_func
        if complete_func=$(radp_cli_get_complete_func "${opt_info[long]}" "${meta[completes]}" 2>/dev/null); then
          # 动态补全 - 使用 wrapper 函数
          local opt_name="${opt_info[long]//-/_}"
          local wrapper_name="_${app_func}_opt_${func_suffix}_${opt_name}"
          echo "${pad}        ${opt_spec}[${desc}]:${opt_info[value_name]}:${wrapper_name}' \\"
        else
          echo "${pad}        ${opt_spec}[${desc}]:${opt_info[value_name]}:' \\"
        fi
      else
        echo "${pad}        ${opt_spec}[${desc}]' \\"
      fi
    fi
  done <<<"${meta[options]}"

  # 收集参数补全规格
  local arg_line arg_idx=1
  local -a arg_specs=()
  while IFS= read -r arg_line; do
    [[ -z "$arg_line" ]] && continue
    local -A arg_info=()
    radp_cli_parse_arg_spec "$arg_line" arg_info

    local complete_func
    if complete_func=$(radp_cli_get_complete_func "${arg_info[name]}" "${meta[completes]}" 2>/dev/null); then
      # 动态补全 - 使用 wrapper 函数
      local wrapper_name="_${app_func}_arg_${func_suffix}_${arg_info[name]}"
      if [[ "${arg_info[variadic]}" == "true" ]]; then
        arg_specs+=("'*:${arg_info[name]}:${wrapper_name}'")
      else
        arg_specs+=("'${arg_idx}:${arg_info[name]}:${wrapper_name}'")
      fi
    else
      if [[ "${arg_info[variadic]}" == "true" ]]; then
        arg_specs+=("'*:${arg_info[name]}:_files'")
      else
        arg_specs+=("'${arg_idx}:${arg_info[name]}:_files'")
      fi
    fi
    ((arg_idx++)) || true
  done <<<"${meta[args]}"

  # 输出参数规格（最后一个不带反斜杠）
  if [[ ${#arg_specs[@]} -eq 0 ]]; then
    # 如果没有参数定义，添加默认文件补全
    echo "${pad}        '*:file:_files'"
  else
    local i
    for ((i = 0; i < ${#arg_specs[@]}; i++)); do
      if [[ $i -eq $((${#arg_specs[@]} - 1)) ]]; then
        # 最后一个参数不带反斜杠
        echo "${pad}        ${arg_specs[$i]}"
      else
        echo "${pad}        ${arg_specs[$i]} \\"
      fi
    done
  fi
}

#######################################
# 生成补全脚本（统一入口）
# Arguments:
#   1 - shell: shell 类型（bash 或 zsh）
# Outputs:
#   补全脚本
# Returns:
#   0 - 成功
#   1 - 不支持的 shell 类型
#######################################
radp_cli_completion_generate() {
  local shell="$1"

  case "$shell" in
  bash)
    radp_cli_completion_bash
    ;;
  zsh)
    radp_cli_completion_zsh
    ;;
  *)
    radp_log_error "Unsupported shell: $shell (supported: bash, zsh)"
    return 1
    ;;
  esac
}
