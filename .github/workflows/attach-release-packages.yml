name: Attach release packages

on:
  workflow_run:
    workflows:
      - Build COPR package
      - Build OBS package
      - Update Homebrew Tap
    types:
      - completed
  workflow_dispatch:

permissions:
  contents: write

jobs:
  attach-release-packages:
    if: >-
      ${{
        github.event_name != 'workflow_run' ||
        (github.event.workflow_run.conclusion == 'success' &&
        github.event.workflow_run.head_branch == 'main')
      }}
    runs-on: ubuntu-latest
    env:
      COPR_PROJECT: ${{ secrets.COPR_PROJECT }}
      OBS_PROJECT: ${{ secrets.OBS_PROJECT }}
      OBS_PACKAGE: ${{ secrets.OBS_PACKAGE }}
      OBS_API_URL: ${{ secrets.OBS_API_URL }}
      TAP_FORMULA_URL: https://raw.githubusercontent.com/xooooooooox/homebrew-radp/HEAD/Formula/radp-bash-framework.rb
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch tags
        run: git fetch --tags --force

      - name: Resolve tag and package
        id: release
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${GITHUB_EVENT_NAME}" == "workflow_run" ]]; then
            head_sha="${{ github.event.workflow_run.head_sha }}"
            tag_name="$(git tag --points-at "${head_sha}" --list 'v*' | sort -V | tail -n 1)"
          else
            tag_name="${GITHUB_REF_NAME}"
          fi

          constants_file="src/main/shell/framework/bootstrap/context/vars/constants/constants.sh"
          if [[ -z "${tag_name}" && "${GITHUB_EVENT_NAME}" == "workflow_run" ]]; then
            version_from_commit="$(git show "${head_sha}:${constants_file}" | sed -n 's/^declare -gr gr_fw_version=//p' | head -n 1)"
            if [[ -z "${version_from_commit}" ]]; then
              echo "Failed to read gr_fw_version from ${constants_file} at ${head_sha}" >&2
              exit 1
            fi
            tag_name="${version_from_commit}"
          fi

          if [[ -z "${tag_name}" ]]; then
            echo "Failed to resolve version tag for event ${GITHUB_EVENT_NAME}" >&2
            exit 1
          fi

          if [[ ! "${tag_name}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Resolved tag '${tag_name}' does not match vx.y.z" >&2
            exit 1
          fi

          should_upload=true
          if ! git rev-parse "${tag_name}" >/dev/null 2>&1; then
            echo "Tag ${tag_name} does not exist yet; skipping release attachment."
            should_upload=false
          fi

          version="${tag_name#v}"
          package_name="$(awk -F': *' '/^Name:/{print $2; exit}' packaging/copr/radp-bash-framework.spec)"
          if [[ -z "${package_name}" ]]; then
            echo "Failed to read package name from packaging/copr/radp-bash-framework.spec" >&2
            exit 1
          fi

          echo "tag_name=${tag_name}" >> "$GITHUB_OUTPUT"
          echo "version=${version}" >> "$GITHUB_OUTPUT"
          echo "package_name=${package_name}" >> "$GITHUB_OUTPUT"
          echo "should_upload=${should_upload}" >> "$GITHUB_OUTPUT"

      - name: Download COPR packages
        if: >-
          ${{
            steps.release.outputs.should_upload == 'true' &&
            (github.event_name != 'workflow_run' ||
            github.event.workflow_run.name == 'Build COPR package')
          }}
        env:
          VERSION: ${{ steps.release.outputs.version }}
          PACKAGE_NAME: ${{ steps.release.outputs.package_name }}
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${COPR_PROJECT:-}" ]]; then
            echo "COPR_PROJECT not set; skipping COPR download."
            exit 0
          fi
          python - <<'PY'
          import json
          import os
          import re
          import sys
          import urllib.parse
          import urllib.request
          from pathlib import Path

          copr_project = os.environ["COPR_PROJECT"].strip()
          version = os.environ["VERSION"].strip()
          package_name = os.environ["PACKAGE_NAME"].strip()

          if "/" not in copr_project:
            print(f"Invalid COPR_PROJECT: {copr_project}", file=sys.stderr)
            sys.exit(0)

          owner, project = copr_project.split("/", 1)

          def request(url: str) -> urllib.request.Request:
            return urllib.request.Request(
              url,
              headers={
                "User-Agent": "radp-release-bot/1.0",
                "Accept": "application/json,text/html;q=0.9,*/*;q=0.8",
              },
            )

          def fetch(url: str) -> tuple[bytes, int, str]:
            req = request(url)
            with urllib.request.urlopen(req) as resp:
              data = resp.read()
              status = getattr(resp, "status", None) or resp.getcode()
              content_type = resp.headers.get("Content-Type", "")
              return data, int(status), content_type

          def api_json(url: str) -> dict:
            data, status, content_type = fetch(url)
            print(
              f"COPR api GET {url} status={status} content-type={content_type} bytes={len(data)}",
              file=sys.stderr,
            )
            if not data:
              raise ValueError(f"Empty response from {url}")
            try:
              return json.loads(data.decode("utf-8"))
            except json.JSONDecodeError as exc:
              snippet = data[:200].decode("utf-8", "ignore")
              raise ValueError(f"Invalid JSON from {url}: {snippet}") from exc

          def download(url: str, dest: Path) -> None:
            dest.parent.mkdir(parents=True, exist_ok=True)
            data, status, content_type = fetch(url)
            if status >= 400:
              raise ValueError(f"Download failed: {url} status={status} content-type={content_type}")
            with open(dest, "wb") as fh:
              fh.write(data)

          print(
            f"COPR lookup owner={owner} project={project} package={package_name} version={version}",
            file=sys.stderr,
          )
          params = {
            "ownername": owner,
            "projectname": project,
            "limit": "50",
          }
          builds_url = "https://copr.fedorainfracloud.org/api_3/build/list?" + urllib.parse.urlencode(params)
          use_fallback = False
          try:
            build_data = api_json(builds_url)
            builds = build_data.get("builds") or build_data.get("items") or []
            print(
              f"COPR build list keys={list(build_data.keys())} count={len(builds)}",
              file=sys.stderr,
            )
          except Exception as exc:
            print(f"Failed to read COPR build list: {exc}", file=sys.stderr)
            builds = []
            use_fallback = True

          candidates = []
          match_package = 0
          match_version = 0
          for build in builds:
            if build.get("state") != "succeeded":
              continue
            source_pkg = build.get("source_package") or {}
            source_name = source_pkg.get("name") or build.get("package_name")
            if source_name and source_name != package_name:
              continue
            if source_name:
              match_package += 1
            src_version = source_pkg.get("version")
            if src_version and not (src_version == version or src_version.startswith(version + "-")):
              continue
            if src_version:
              match_version += 1
            candidates.append(build)

          if not candidates:
            print(f"No COPR builds found for {package_name} {version}; falling back to result crawl.", file=sys.stderr)
            candidates = []
            use_fallback = True
          else:
            print(
              f"COPR build list size={len(builds)} package_matches={match_package} version_matches={match_version} candidates={len(candidates)}",
              file=sys.stderr,
            )

          urls = []
          if candidates:
            selected = max(candidates, key=lambda b: b.get("id", 0))
            build_id = selected.get("id")
            repo_url = (selected.get("repo_url") or "").rstrip("/")
            chroots = selected.get("chroots") or []
            if repo_url:
              urls.append(repo_url + "/")
              for chroot in chroots:
                urls.append(f"{repo_url}/{chroot}/")
                urls.append(f"{repo_url}/{chroot}/{package_name}/")
              print(
                f"COPR selected build_id={build_id} repo_url={repo_url} chroots={len(chroots)}",
                file=sys.stderr,
              )
            else:
              use_fallback = True

          if candidates and (not urls or use_fallback):
            build_id = max(candidates, key=lambda b: b.get("id", 0)).get("id")
            try:
              build_info = api_json(f"https://copr.fedorainfracloud.org/api_3/build/get?build_id={build_id}")
            except Exception as exc:
              print(f"Failed to read COPR build info: {exc}", file=sys.stderr)
              build_info = {}
              use_fallback = True
            build = build_info.get("build", {})
            result_url = (build.get("result_url") or "").rstrip("/")
            chroots = build.get("chroots") or []
            if result_url:
              urls.append(result_url + "/")
              for chroot in chroots:
                urls.append(f"{result_url}/{chroot}/")
            else:
              use_fallback = True

          if use_fallback or not urls:
            urls = [f"https://download.copr.fedorainfracloud.org/results/{owner}/{project}/"]
            print(f"COPR fallback crawl roots: {urls}", file=sys.stderr)

          def fetch_listing(url: str) -> str:
            data, status, content_type = fetch(url)
            if status >= 400:
              raise ValueError(f"Listing failed: {url} status={status} content-type={content_type}")
            return data.decode("utf-8", "ignore")

          dest_dir = Path("release-assets/copr")
          downloaded = set()
          visited = set()
          queue = [(url, 0) for url in urls]
          max_depth = 3
          max_pages = 120
          matched_rpms = 0
          href_log_budget = 6

          while queue and max_pages > 0:
            base_url, depth = queue.pop(0)
            if base_url in visited:
              continue
            visited.add(base_url)
            max_pages -= 1
            print(f"COPR crawl url={base_url} depth={depth}", file=sys.stderr)
            try:
              listing = fetch_listing(base_url)
            except Exception:
              continue
            hrefs = re.findall(r'href=["\']([^"\']+)["\']', listing)
            if href_log_budget > 0 and hrefs:
              sample = ", ".join(hrefs[:5])
              print(f"COPR href sample: {sample}", file=sys.stderr)
              href_log_budget -= 1
            for href in hrefs:
              if href in ("../", "./"):
                continue
              href_clean = href.split("?", 1)[0].split("#", 1)[0]
              full_url = urllib.parse.urljoin(base_url, href_clean)
              is_dir = href_clean.endswith("/")
              if not is_dir:
                has_ext = "." in href_clean.rsplit("/", 1)[-1]
                if not has_ext and not href_clean.endswith(".rpm"):
                  is_dir = True
              if is_dir:
                if not full_url.endswith("/"):
                  full_url += "/"
                if depth < max_depth:
                  queue.append((full_url, depth + 1))
                continue
                if depth < max_depth:
                  queue.append((full_url, depth + 1))
                continue
              if not href_clean.endswith(".rpm"):
                continue
              filename = href_clean.split("/")[-1]
              if package_name not in filename or version not in filename:
                continue
              matched_rpms += 1
              if filename in downloaded:
                continue
              download(full_url, dest_dir / f"copr-{filename}")
              downloaded.add(filename)

          if not downloaded:
            print(f"No COPR RPMs downloaded for {package_name} {version}", file=sys.stderr)
          else:
            print(
              f"Downloaded {len(downloaded)} COPR RPMs (matched={matched_rpms} visited={len(visited)} pages)",
              file=sys.stderr,
            )
          PY

      - name: Download OBS packages
        if: >-
          ${{
            steps.release.outputs.should_upload == 'true' &&
            (github.event_name != 'workflow_run' ||
            github.event.workflow_run.name == 'Build OBS package')
          }}
        env:
          VERSION: ${{ steps.release.outputs.version }}
          PACKAGE_NAME: ${{ steps.release.outputs.package_name }}
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${OBS_PROJECT:-}" ]]; then
            echo "OBS_PROJECT not set; skipping OBS download."
            exit 0
          fi
          python - <<'PY'
          import os
          import sys
          import urllib.parse
          import urllib.request
          import xml.etree.ElementTree as ET
          from pathlib import Path

          project = os.environ["OBS_PROJECT"].strip()
          package = (os.environ.get("OBS_PACKAGE") or os.environ.get("PACKAGE_NAME") or "").strip()
          version = os.environ["VERSION"].strip()
          api_url = (os.environ.get("OBS_API_URL") or "https://api.opensuse.org").rstrip("/")

          if not package:
            print("OBS package name is missing", file=sys.stderr)
            sys.exit(0)

          def quote(segment: str) -> str:
            return urllib.parse.quote(segment, safe="")

          def fetch_xml(url: str) -> ET.Element:
            with urllib.request.urlopen(url) as resp:
              return ET.fromstring(resp.read())

          def download(url: str, dest: Path) -> None:
            dest.parent.mkdir(parents=True, exist_ok=True)
            with urllib.request.urlopen(url) as resp, open(dest, "wb") as fh:
              fh.write(resp.read())

          project_q = quote(project)
          package_q = quote(package)
          result_url = f"{api_url}/build/{project_q}/_result?package={package_q}"
          try:
            root = fetch_xml(result_url)
          except Exception as exc:
            print(f"Failed to query OBS results: {exc}", file=sys.stderr)
            sys.exit(0)

          candidates = []
          for result in root.findall(".//result"):
            repo = result.get("repository")
            arch = result.get("arch")
            if not repo or not arch:
              continue
            status_nodes = result.findall(f"./status[@package='{package}']")
            if not status_nodes:
              continue
            status = status_nodes[0]
            code = (status.get("code") or status.get("state") or "").lower()
            if code not in {"succeeded", "published", "finished", "unchanged"}:
              continue
            candidates.append((repo, arch))

          if not candidates:
            print(f"No successful OBS results for {package}", file=sys.stderr)
            sys.exit(0)

          dest_dir = Path("release-assets/obs")
          downloaded = set()

          for repo, arch in candidates:
            repo_q = quote(repo)
            arch_q = quote(arch)
            binarylist_url = f"{api_url}/build/{project_q}/{repo_q}/{arch_q}/{package_q}?view=binarylist"
            try:
              binaries_root = fetch_xml(binarylist_url)
            except Exception:
              continue
            for binary in binaries_root.findall(".//binary"):
              filename = binary.get("filename")
              if not filename:
                continue
              if version not in filename:
                continue
              if filename in downloaded:
                continue
              file_url = (
                f"{api_url}/build/{project_q}/{repo_q}/{arch_q}/{package_q}/"
                f"{urllib.parse.quote(filename, safe='')}"
              )
              download(file_url, dest_dir / f"obs-{filename}")
              downloaded.add(filename)

          if not downloaded:
            print(f"No OBS binaries downloaded for {package} {version}", file=sys.stderr)
          else:
            print(f"Downloaded {len(downloaded)} OBS binaries")
          PY

      - name: Download Homebrew formula
        if: >-
          ${{
            steps.release.outputs.should_upload == 'true' &&
            (github.event_name != 'workflow_run' ||
            github.event.workflow_run.name == 'Update Homebrew Tap')
          }}
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${TAP_FORMULA_URL:-}" ]]; then
            echo "TAP_FORMULA_URL not set; skipping formula download."
            exit 0
          fi
          mkdir -p release-assets/homebrew
          curl -L --fail --show-error -o release-assets/homebrew/homebrew-radp-bash-framework.rb "${TAP_FORMULA_URL}"

      - name: Upload assets to release
        if: steps.release.outputs.should_upload == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          tag="${{ steps.release.outputs.tag_name }}"
          if ! gh release view "$tag" >/dev/null 2>&1; then
            gh release create "$tag" --title "$tag" --generate-notes
          fi
          if [[ ! -d release-assets ]]; then
            echo "No assets directory to upload."
            exit 0
          fi
          mapfile -t assets < <(find release-assets -maxdepth 3 -type f | sort)
          if [[ ${#assets[@]} -eq 0 ]]; then
            echo "No assets to upload."
            exit 0
          fi
          gh release upload "$tag" "${assets[@]}" --clobber
